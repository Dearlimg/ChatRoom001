// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: setting.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createManySetting = `-- name: CreateManySetting :exec
INSERT INTO settings (account_id, relation_id, nick_name)
VALUES (?, ?, ?)
`

type CreateManySettingParams struct {
	AccountID  int64  `json:"account_id"`
	RelationID int64  `json:"relation_id"`
	NickName   string `json:"nick_name"`
}

func (q *Queries) CreateManySetting(ctx context.Context, arg *CreateManySettingParams) error {
	_, err := q.exec(ctx, q.createManySettingStmt, createManySetting, arg.AccountID, arg.RelationID, arg.NickName)
	return err
}

const createSetting = `-- name: CreateSetting :exec
insert into settings (account_id, relation_id, nick_name,is_leader,is_self)
values (?,?,'',?,?)
`

type CreateSettingParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
	IsLeader   bool  `json:"is_leader"`
	IsSelf     bool  `json:"is_self"`
}

func (q *Queries) CreateSetting(ctx context.Context, arg *CreateSettingParams) error {
	_, err := q.exec(ctx, q.createSettingStmt, createSetting,
		arg.AccountID,
		arg.RelationID,
		arg.IsLeader,
		arg.IsSelf,
	)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM settings
WHERE relation_id = ?
`

func (q *Queries) DeleteGroup(ctx context.Context, relationID int64) error {
	_, err := q.exec(ctx, q.deleteGroupStmt, deleteGroup, relationID)
	return err
}

const deleteSetting = `-- name: DeleteSetting :exec
delete
from settings
where account_id = ?
and relation_id = ?
`

type DeleteSettingParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
}

func (q *Queries) DeleteSetting(ctx context.Context, arg *DeleteSettingParams) error {
	_, err := q.exec(ctx, q.deleteSettingStmt, deleteSetting, arg.AccountID, arg.RelationID)
	return err
}

const deleteSettingsByAccountID = `-- name: DeleteSettingsByAccountID :exec
delete
from settings
where account_id =?
`

func (q *Queries) DeleteSettingsByAccountID(ctx context.Context, accountID int64) error {
	_, err := q.exec(ctx, q.deleteSettingsByAccountIDStmt, deleteSettingsByAccountID, accountID)
	return err
}

const existGroupLeaderByAccountIDWithLock = `-- name: ExistGroupLeaderByAccountIDWithLock :one
select exists(select 1
              from settings
              where account_id =?
              and is_leader=true)
`

func (q *Queries) ExistGroupLeaderByAccountIDWithLock(ctx context.Context, accountID int64) (bool, error) {
	row := q.queryRow(ctx, q.existGroupLeaderByAccountIDWithLockStmt, existGroupLeaderByAccountIDWithLock, accountID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsFriendSetting = `-- name: ExistsFriendSetting :one
SELECT EXISTS (
    SELECT 1
    FROM settings s, relations r
    WHERE
        r.relation_type = 'friend'
      AND (
        (r.account1_id = ? AND r.account2_id = ?)
            OR
        (r.account1_id = ? AND r.account2_id = ?)
        )
      AND s.account_id = ?
)
`

type ExistsFriendSettingParams struct {
	Account1ID   sql.NullInt64 `json:"account1_id"`
	Account2ID   sql.NullInt64 `json:"account2_id"`
	Account1ID_2 sql.NullInt64 `json:"account1_id_2"`
	Account2ID_2 sql.NullInt64 `json:"account2_id_2"`
	AccountID    int64         `json:"account_id"`
}

func (q *Queries) ExistsFriendSetting(ctx context.Context, arg *ExistsFriendSettingParams) (bool, error) {
	row := q.queryRow(ctx, q.existsFriendSettingStmt, existsFriendSetting,
		arg.Account1ID,
		arg.Account2ID,
		arg.Account1ID_2,
		arg.Account2ID_2,
		arg.AccountID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsIsLeader = `-- name: ExistsIsLeader :one
SELECT EXISTS (
    SELECT 1
    FROM settings
    WHERE relation_id = ? AND account_id = ? AND is_leader = 1
)
`

type ExistsIsLeaderParams struct {
	RelationID int64 `json:"relation_id"`
	AccountID  int64 `json:"account_id"`
}

func (q *Queries) ExistsIsLeader(ctx context.Context, arg *ExistsIsLeaderParams) (bool, error) {
	row := q.queryRow(ctx, q.existsIsLeaderStmt, existsIsLeader, arg.RelationID, arg.AccountID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsSetting = `-- name: ExistsSetting :one
SELECT EXISTS (
    SELECT 1
    FROM settings
    WHERE account_id = ? AND relation_id = ?
)
`

type ExistsSettingParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
}

func (q *Queries) ExistsSetting(ctx context.Context, arg *ExistsSettingParams) (bool, error) {
	row := q.queryRow(ctx, q.existsSettingStmt, existsSetting, arg.AccountID, arg.RelationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAccountIDsByRelationID = `-- name: GetAccountIDsByRelationID :many
SELECT DISTINCT account_id
FROM settings
WHERE relation_id = ?
`

func (q *Queries) GetAccountIDsByRelationID(ctx context.Context, relationID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.getAccountIDsByRelationIDStmt, getAccountIDsByRelationID, relationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendPinSettingsOrderByPinTime = `-- name: GetFriendPinSettingsOrderByPinTime :many
select s.relation_id, s.nick_name, s.pin_time,
       a.id as account_id,
       a.name as account_name,
       a.avatar as account_avatar
from (select settings.relation_id, settings.nick_name, settings.pin_time
      from settings,
           relations
      where settings.account_id = ?
        and settings.is_pin = true
        and settings.relation_id = relations.id
        and relations.relation_type = 'friend') as s,
     accounts a
where a.id = (select account_id from settings where relation_id = s.relation_id and (settings.account_id != ? or is_self = true))
order by s.pin_time
`

type GetFriendPinSettingsOrderByPinTimeParams struct {
	AccountID   int64 `json:"account_id"`
	AccountID_2 int64 `json:"account_id_2"`
}

type GetFriendPinSettingsOrderByPinTimeRow struct {
	RelationID    int64     `json:"relation_id"`
	NickName      string    `json:"nick_name"`
	PinTime       time.Time `json:"pin_time"`
	AccountID     int64     `json:"account_id"`
	AccountName   string    `json:"account_name"`
	AccountAvatar string    `json:"account_avatar"`
}

func (q *Queries) GetFriendPinSettingsOrderByPinTime(ctx context.Context, arg *GetFriendPinSettingsOrderByPinTimeParams) ([]*GetFriendPinSettingsOrderByPinTimeRow, error) {
	rows, err := q.query(ctx, q.getFriendPinSettingsOrderByPinTimeStmt, getFriendPinSettingsOrderByPinTime, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetFriendPinSettingsOrderByPinTimeRow
	for rows.Next() {
		var i GetFriendPinSettingsOrderByPinTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.PinTime,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendSettingsByName = `-- name: GetFriendSettingsByName :many
SELECT
    s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
    a.id AS account_id,
    a.name AS account_name,
    a.avatar AS account_avatar,
    COUNT(*) OVER () AS total
FROM (
         SELECT
             s.relation_id,
             s.nick_name,
             s.is_not_disturb,
             s.is_pin,
             s.pin_time,
             s.is_show,
             s.last_show,
             s.is_self
         FROM settings s
                  INNER JOIN relations r ON s.relation_id = r.id
         WHERE
             s.account_id = ?
           AND r.relation_type = 'friend'
     ) AS s
         CROSS JOIN accounts a
WHERE
    a.id = (
        SELECT account_id
        FROM settings
        WHERE
            relation_id = s.relation_id
          AND (settings.account_id != ? OR s.is_self = 1)
    )
  AND (
    a.name LIKE CONCAT('%', ?, '%')
        OR s.nick_name LIKE CONCAT('%', ?, '%')
    )
ORDER BY a.name
LIMIT ? OFFSET ?
`

type GetFriendSettingsByNameParams struct {
	AccountID   int64       `json:"account_id"`
	AccountID_2 int64       `json:"account_id_2"`
	CONCAT      interface{} `json:"CONCAT"`
	CONCAT_2    interface{} `json:"CONCAT_2"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

type GetFriendSettingsByNameRow struct {
	RelationID    int64       `json:"relation_id"`
	NickName      string      `json:"nick_name"`
	IsNotDisturb  bool        `json:"is_not_disturb"`
	IsPin         bool        `json:"is_pin"`
	PinTime       time.Time   `json:"pin_time"`
	IsShow        bool        `json:"is_show"`
	LastShow      time.Time   `json:"last_show"`
	IsSelf        bool        `json:"is_self"`
	AccountID     int64       `json:"account_id"`
	AccountName   string      `json:"account_name"`
	AccountAvatar string      `json:"account_avatar"`
	Total         interface{} `json:"total"`
}

func (q *Queries) GetFriendSettingsByName(ctx context.Context, arg *GetFriendSettingsByNameParams) ([]*GetFriendSettingsByNameRow, error) {
	rows, err := q.query(ctx, q.getFriendSettingsByNameStmt, getFriendSettingsByName,
		arg.AccountID,
		arg.AccountID_2,
		arg.CONCAT,
		arg.CONCAT_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetFriendSettingsByNameRow
	for rows.Next() {
		var i GetFriendSettingsByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendSettingsOrderByName = `-- name: GetFriendSettingsOrderByName :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       a.id as account_id,
       a.name as account_name,
       a.avatar as account_avatar
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from settings,
           relations
      where settings.account_id = ?
        and settings.relation_id = relations.id
        and relations.relation_type = 'friend') as s,
     accounts a
where a.id = (select account_id from settings where relation_id = s.relation_id and (settings.account_id != ? or s.is_self = true))
order by a.name
`

type GetFriendSettingsOrderByNameParams struct {
	AccountID   int64 `json:"account_id"`
	AccountID_2 int64 `json:"account_id_2"`
}

type GetFriendSettingsOrderByNameRow struct {
	RelationID    int64     `json:"relation_id"`
	NickName      string    `json:"nick_name"`
	IsNotDisturb  bool      `json:"is_not_disturb"`
	IsPin         bool      `json:"is_pin"`
	PinTime       time.Time `json:"pin_time"`
	IsShow        bool      `json:"is_show"`
	LastShow      time.Time `json:"last_show"`
	IsSelf        bool      `json:"is_self"`
	AccountID     int64     `json:"account_id"`
	AccountName   string    `json:"account_name"`
	AccountAvatar string    `json:"account_avatar"`
}

func (q *Queries) GetFriendSettingsOrderByName(ctx context.Context, arg *GetFriendSettingsOrderByNameParams) ([]*GetFriendSettingsOrderByNameRow, error) {
	rows, err := q.query(ctx, q.getFriendSettingsOrderByNameStmt, getFriendSettingsOrderByName, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetFriendSettingsOrderByNameRow
	for rows.Next() {
		var i GetFriendSettingsOrderByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendShowSettingsOrderByShowTime = `-- name: GetFriendShowSettingsOrderByShowTime :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       a.id as account_id,
       a.name as account_name,
       a.avatar as account_avatar
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from settings,
           relations
      where settings.account_id = ?
        and settings.is_show = true
        and settings.relation_id = relations.id
        and relations.relation_type = 'friend') as s,
     accounts a
where a.id = (select account_id from settings where relation_id = s.relation_id and (settings.account_id != ? or is_self = true))
order by s.last_show desc
`

type GetFriendShowSettingsOrderByShowTimeParams struct {
	AccountID   int64 `json:"account_id"`
	AccountID_2 int64 `json:"account_id_2"`
}

type GetFriendShowSettingsOrderByShowTimeRow struct {
	RelationID    int64     `json:"relation_id"`
	NickName      string    `json:"nick_name"`
	IsNotDisturb  bool      `json:"is_not_disturb"`
	IsPin         bool      `json:"is_pin"`
	PinTime       time.Time `json:"pin_time"`
	IsShow        bool      `json:"is_show"`
	LastShow      time.Time `json:"last_show"`
	IsSelf        bool      `json:"is_self"`
	AccountID     int64     `json:"account_id"`
	AccountName   string    `json:"account_name"`
	AccountAvatar string    `json:"account_avatar"`
}

func (q *Queries) GetFriendShowSettingsOrderByShowTime(ctx context.Context, arg *GetFriendShowSettingsOrderByShowTimeParams) ([]*GetFriendShowSettingsOrderByShowTimeRow, error) {
	rows, err := q.query(ctx, q.getFriendShowSettingsOrderByShowTimeStmt, getFriendShowSettingsOrderByShowTime, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetFriendShowSettingsOrderByShowTimeRow
	for rows.Next() {
		var i GetFriendShowSettingsOrderByShowTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupList = `-- name: GetGroupList :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       r.id as relation_id,
       r.group_name as group_name,
       r.group_description as group_discription,
       r.group_avatar as group_avatar,
       count(*) over () as total
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from settings,
           relations
      where settings.account_id = ?
        and settings.relation_id = relations.id
        and relations.relation_type = 'group') as s,
    relations r
where r.id = (select s.relation_id from settings where relation_id = s.relation_id and (settings.account_id = ?))
order by s.last_show
`

type GetGroupListParams struct {
	AccountID   int64 `json:"account_id"`
	AccountID_2 int64 `json:"account_id_2"`
}

type GetGroupListRow struct {
	RelationID       int64          `json:"relation_id"`
	NickName         string         `json:"nick_name"`
	IsNotDisturb     bool           `json:"is_not_disturb"`
	IsPin            bool           `json:"is_pin"`
	PinTime          time.Time      `json:"pin_time"`
	IsShow           bool           `json:"is_show"`
	LastShow         time.Time      `json:"last_show"`
	IsSelf           bool           `json:"is_self"`
	RelationID_2     int64          `json:"relation_id_2"`
	GroupName        sql.NullString `json:"group_name"`
	GroupDiscription sql.NullString `json:"group_discription"`
	GroupAvatar      sql.NullString `json:"group_avatar"`
	Total            interface{}    `json:"total"`
}

func (q *Queries) GetGroupList(ctx context.Context, arg *GetGroupListParams) ([]*GetGroupListRow, error) {
	rows, err := q.query(ctx, q.getGroupListStmt, getGroupList, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetGroupListRow
	for rows.Next() {
		var i GetGroupListRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.RelationID_2,
			&i.GroupName,
			&i.GroupDiscription,
			&i.GroupAvatar,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembers = `-- name: GetGroupMembers :many
SELECT account_id
FROM settings
WHERE relation_id = ?
`

func (q *Queries) GetGroupMembers(ctx context.Context, relationID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.getGroupMembersStmt, getGroupMembers, relationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembersByID = `-- name: GetGroupMembersByID :many
SELECT
    a.id,
    a.name,
    a.avatar,
    s.nick_name,
    s.is_leader
FROM accounts a
         LEFT JOIN settings s ON a.id = s.account_id
WHERE s.relation_id = ?
LIMIT ? OFFSET ?
`

type GetGroupMembersByIDParams struct {
	RelationID int64 `json:"relation_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetGroupMembersByIDRow struct {
	ID       int64          `json:"id"`
	Name     string         `json:"name"`
	Avatar   string         `json:"avatar"`
	NickName sql.NullString `json:"nick_name"`
	IsLeader sql.NullBool   `json:"is_leader"`
}

func (q *Queries) GetGroupMembersByID(ctx context.Context, arg *GetGroupMembersByIDParams) ([]*GetGroupMembersByIDRow, error) {
	rows, err := q.query(ctx, q.getGroupMembersByIDStmt, getGroupMembersByID, arg.RelationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetGroupMembersByIDRow
	for rows.Next() {
		var i GetGroupMembersByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.NickName,
			&i.IsLeader,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupPinSettingsOrderByPinTime = `-- name: GetGroupPinSettingsOrderByPinTime :many
select s.relation_id,
       s.nick_name,
       s.pin_time,
        r.id,
        r.group_name,
        r.group_description,
        r.group_avatar
from (select settings.relation_id,settings.nick_name,settings.pin_time
      from settings,
           relations
      where settings.account_id = ?
      and settings.relation_id=relations.id
      and settings.is_pin=true
      and relation_type='group') as s,
    relations r
where r.id=(select relation_id
            from settings
            where relation_id = s.relation_id
            and settings.account_id = ?)
order by s.pin_time
`

type GetGroupPinSettingsOrderByPinTimeParams struct {
	AccountID   int64 `json:"account_id"`
	AccountID_2 int64 `json:"account_id_2"`
}

type GetGroupPinSettingsOrderByPinTimeRow struct {
	RelationID       int64          `json:"relation_id"`
	NickName         string         `json:"nick_name"`
	PinTime          time.Time      `json:"pin_time"`
	ID               int64          `json:"id"`
	GroupName        sql.NullString `json:"group_name"`
	GroupDescription sql.NullString `json:"group_description"`
	GroupAvatar      sql.NullString `json:"group_avatar"`
}

func (q *Queries) GetGroupPinSettingsOrderByPinTime(ctx context.Context, arg *GetGroupPinSettingsOrderByPinTimeParams) ([]*GetGroupPinSettingsOrderByPinTimeRow, error) {
	rows, err := q.query(ctx, q.getGroupPinSettingsOrderByPinTimeStmt, getGroupPinSettingsOrderByPinTime, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetGroupPinSettingsOrderByPinTimeRow
	for rows.Next() {
		var i GetGroupPinSettingsOrderByPinTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.PinTime,
			&i.ID,
			&i.GroupName,
			&i.GroupDescription,
			&i.GroupAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupSettingsByName = `-- name: GetGroupSettingsByName :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       r.id as realtion_id,
       r.group_name AS group_name,       -- 假设 group_type.name 映射为 group_type_name 字段
       r.group_avatar AS group_avatar,   -- 假设 group_type.avatar 映射为 group_type_avatar 字段
       r.group_description AS description,
       count(*) over () as total
from (select relation_id,
    nick_name,
    is_not_disturb,
    is_pin,
    pin_time,
    is_show,
    last_show,
    is_self
    from settings,
    relations
    where settings.account_id = ?
    and settings.relation_id = relations.id
    and relations.relation_type = 'group') as s,
    relations r
where r.id = (select s.relation_id from settings where s.relation_id=s.relation_id and (settings.account_id=?))
    and ((r.group_name like ('%' || @name || '%')))
order by (r.group_name)
limit ? offset ?
`

type GetGroupSettingsByNameParams struct {
	AccountID   int64 `json:"account_id"`
	AccountID_2 int64 `json:"account_id_2"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type GetGroupSettingsByNameRow struct {
	RelationID   int64          `json:"relation_id"`
	NickName     string         `json:"nick_name"`
	IsNotDisturb bool           `json:"is_not_disturb"`
	IsPin        bool           `json:"is_pin"`
	PinTime      time.Time      `json:"pin_time"`
	IsShow       bool           `json:"is_show"`
	LastShow     time.Time      `json:"last_show"`
	IsSelf       bool           `json:"is_self"`
	RealtionID   int64          `json:"realtion_id"`
	GroupName    sql.NullString `json:"group_name"`
	GroupAvatar  sql.NullString `json:"group_avatar"`
	Description  sql.NullString `json:"description"`
	Total        interface{}    `json:"total"`
}

func (q *Queries) GetGroupSettingsByName(ctx context.Context, arg *GetGroupSettingsByNameParams) ([]*GetGroupSettingsByNameRow, error) {
	rows, err := q.query(ctx, q.getGroupSettingsByNameStmt, getGroupSettingsByName,
		arg.AccountID,
		arg.AccountID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetGroupSettingsByNameRow
	for rows.Next() {
		var i GetGroupSettingsByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.RealtionID,
			&i.GroupName,
			&i.GroupAvatar,
			&i.Description,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationIDByAccountIDFromSettings = `-- name: GetRelationIDByAccountIDFromSettings :many
select relation_id
FROM settings
where account_id = ?
`

func (q *Queries) GetRelationIDByAccountIDFromSettings(ctx context.Context, accountID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.getRelationIDByAccountIDFromSettingsStmt, getRelationIDByAccountIDFromSettings, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var relation_id int64
		if err := rows.Scan(&relation_id); err != nil {
			return nil, err
		}
		items = append(items, relation_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettingByID = `-- name: GetSettingByID :one
select account_id, relation_id, nick_name, is_not_disturb, is_pin, pin_time, is_show, last_show, is_leader, is_self
from settings
where account_id = ?
and relation_id =?
`

type GetSettingByIDParams struct {
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
}

func (q *Queries) GetSettingByID(ctx context.Context, arg *GetSettingByIDParams) (*Setting, error) {
	row := q.queryRow(ctx, q.getSettingByIDStmt, getSettingByID, arg.AccountID, arg.RelationID)
	var i Setting
	err := row.Scan(
		&i.AccountID,
		&i.RelationID,
		&i.NickName,
		&i.IsNotDisturb,
		&i.IsPin,
		&i.PinTime,
		&i.IsShow,
		&i.LastShow,
		&i.IsLeader,
		&i.IsSelf,
	)
	return &i, err
}

const transferIsLeaderFalse = `-- name: TransferIsLeaderFalse :exec
UPDATE settings
SET is_leader = 0
WHERE relation_id = ? AND account_id = ?
`

type TransferIsLeaderFalseParams struct {
	RelationID int64 `json:"relation_id"`
	AccountID  int64 `json:"account_id"`
}

func (q *Queries) TransferIsLeaderFalse(ctx context.Context, arg *TransferIsLeaderFalseParams) error {
	_, err := q.exec(ctx, q.transferIsLeaderFalseStmt, transferIsLeaderFalse, arg.RelationID, arg.AccountID)
	return err
}

const transferIsLeaderTrue = `-- name: TransferIsLeaderTrue :exec
UPDATE settings
SET is_leader = 1
WHERE relation_id = ? AND account_id = ?
`

type TransferIsLeaderTrueParams struct {
	RelationID int64 `json:"relation_id"`
	AccountID  int64 `json:"account_id"`
}

func (q *Queries) TransferIsLeaderTrue(ctx context.Context, arg *TransferIsLeaderTrueParams) error {
	_, err := q.exec(ctx, q.transferIsLeaderTrueStmt, transferIsLeaderTrue, arg.RelationID, arg.AccountID)
	return err
}

const updateSettingDisturb = `-- name: UpdateSettingDisturb :exec
update settings
set is_not_disturb = ?
where account_id = ?
and relation_id =?
`

type UpdateSettingDisturbParams struct {
	IsNotDisturb bool  `json:"is_not_disturb"`
	AccountID    int64 `json:"account_id"`
	RelationID   int64 `json:"relation_id"`
}

func (q *Queries) UpdateSettingDisturb(ctx context.Context, arg *UpdateSettingDisturbParams) error {
	_, err := q.exec(ctx, q.updateSettingDisturbStmt, updateSettingDisturb, arg.IsNotDisturb, arg.AccountID, arg.RelationID)
	return err
}

const updateSettingNickName = `-- name: UpdateSettingNickName :exec
update settings
set nick_name = ?
where account_id =?
and relation_id =?
`

type UpdateSettingNickNameParams struct {
	NickName   string `json:"nick_name"`
	AccountID  int64  `json:"account_id"`
	RelationID int64  `json:"relation_id"`
}

func (q *Queries) UpdateSettingNickName(ctx context.Context, arg *UpdateSettingNickNameParams) error {
	_, err := q.exec(ctx, q.updateSettingNickNameStmt, updateSettingNickName, arg.NickName, arg.AccountID, arg.RelationID)
	return err
}

const updateSettingShow = `-- name: UpdateSettingShow :exec
update settings
set  is_show = ?
where account_id =?
and relation_id =?
`

type UpdateSettingShowParams struct {
	IsShow     bool  `json:"is_show"`
	AccountID  int64 `json:"account_id"`
	RelationID int64 `json:"relation_id"`
}

func (q *Queries) UpdateSettingShow(ctx context.Context, arg *UpdateSettingShowParams) error {
	_, err := q.exec(ctx, q.updateSettingShowStmt, updateSettingShow, arg.IsShow, arg.AccountID, arg.RelationID)
	return err
}
