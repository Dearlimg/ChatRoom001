// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: setting.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createManySetting = `-- name: CreateManySetting :exec
INSERT INTO settings (account_id, relation_id, nick_name)
VALUES (?, ?, ?)
`

type CreateManySettingParams struct {
	AccountID  int64
	RelationID int64
	NickName   string
}

func (q *Queries) CreateManySetting(ctx context.Context, arg *CreateManySettingParams) error {
	_, err := q.exec(ctx, q.createManySettingStmt, createManySetting, arg.AccountID, arg.RelationID, arg.NickName)
	return err
}

const createSetting = `-- name: CreateSetting :exec
insert into settings (account_id, relation_id, nick_name,is_leader,is_self)
values (?,?,?,?,?)
`

type CreateSettingParams struct {
	AccountID  int64
	RelationID int64
	NickName   string
	IsLeader   bool
	IsSelf     bool
}

func (q *Queries) CreateSetting(ctx context.Context, arg *CreateSettingParams) error {
	_, err := q.exec(ctx, q.createSettingStmt, createSetting,
		arg.AccountID,
		arg.RelationID,
		arg.NickName,
		arg.IsLeader,
		arg.IsSelf,
	)
	return err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM settings
WHERE relation_id = ?
`

func (q *Queries) DeleteGroup(ctx context.Context, relationID int64) error {
	_, err := q.exec(ctx, q.deleteGroupStmt, deleteGroup, relationID)
	return err
}

const deleteSetting = `-- name: DeleteSetting :exec
delete
from settings
where account_id = ?
and relation_id = ?
`

type DeleteSettingParams struct {
	AccountID  int64
	RelationID int64
}

func (q *Queries) DeleteSetting(ctx context.Context, arg *DeleteSettingParams) error {
	_, err := q.exec(ctx, q.deleteSettingStmt, deleteSetting, arg.AccountID, arg.RelationID)
	return err
}

const deleteSettingsByAccountID = `-- name: DeleteSettingsByAccountID :exec
delete
from settings
where account_id =?
`

func (q *Queries) DeleteSettingsByAccountID(ctx context.Context, accountID int64) error {
	_, err := q.exec(ctx, q.deleteSettingsByAccountIDStmt, deleteSettingsByAccountID, accountID)
	return err
}

const existGroupLeaderByAccountIDWithLock = `-- name: ExistGroupLeaderByAccountIDWithLock :one
select exists(select 1
              from settings
              where account_id =?
              and is_leader=true)
`

func (q *Queries) ExistGroupLeaderByAccountIDWithLock(ctx context.Context, accountID int64) (bool, error) {
	row := q.queryRow(ctx, q.existGroupLeaderByAccountIDWithLockStmt, existGroupLeaderByAccountIDWithLock, accountID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsFriendSetting = `-- name: ExistsFriendSetting :one
SELECT EXISTS (
    SELECT 1
    FROM settings s, relations r
    WHERE
        r.relation_type = 'friend'
      AND (
        (r.account1_id = ? AND r.account2_id = ?)
            OR
        (r.account1_id = ? AND r.account2_id = ?)
        )
      AND s.account_id = ?
)
`

type ExistsFriendSettingParams struct {
	Account1ID   sql.NullInt64
	Account2ID   sql.NullInt64
	Account1ID_2 sql.NullInt64
	Account2ID_2 sql.NullInt64
	AccountID    int64
}

func (q *Queries) ExistsFriendSetting(ctx context.Context, arg *ExistsFriendSettingParams) (bool, error) {
	row := q.queryRow(ctx, q.existsFriendSettingStmt, existsFriendSetting,
		arg.Account1ID,
		arg.Account2ID,
		arg.Account1ID_2,
		arg.Account2ID_2,
		arg.AccountID,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsIsLeader = `-- name: ExistsIsLeader :one
SELECT EXISTS (
    SELECT 1
    FROM settings
    WHERE relation_id = ? AND account_id = ? AND is_leader = 1
)
`

type ExistsIsLeaderParams struct {
	RelationID int64
	AccountID  int64
}

func (q *Queries) ExistsIsLeader(ctx context.Context, arg *ExistsIsLeaderParams) (bool, error) {
	row := q.queryRow(ctx, q.existsIsLeaderStmt, existsIsLeader, arg.RelationID, arg.AccountID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existsSetting = `-- name: ExistsSetting :one
SELECT EXISTS (
    SELECT 1
    FROM settings
    WHERE account_id = ? AND relation_id = ?
)
`

type ExistsSettingParams struct {
	AccountID  int64
	RelationID int64
}

func (q *Queries) ExistsSetting(ctx context.Context, arg *ExistsSettingParams) (bool, error) {
	row := q.queryRow(ctx, q.existsSettingStmt, existsSetting, arg.AccountID, arg.RelationID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAccountIDsByRelationID = `-- name: GetAccountIDsByRelationID :many
SELECT DISTINCT account_id
FROM settings
WHERE relation_id = ?
`

func (q *Queries) GetAccountIDsByRelationID(ctx context.Context, relationID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.getAccountIDsByRelationIDStmt, getAccountIDsByRelationID, relationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendPinSettingsOrderByPinTime = `-- name: GetFriendPinSettingsOrderByPinTime :many
select s.relation_id, s.nick_name, s.pin_time, s.is_pin, s.is_show, s.is_not_disturb,
       a.id as account_id,
       a.name as account_name,
       a.avatar as account_avatar
from (select settings.relation_id, settings.nick_name, settings.pin_time,settings.is_pin,settings.is_show,settings.is_not_disturb
      from settings,
           relations
      where settings.account_id = ?
        and settings.is_pin = true
        and settings.relation_id = relations.id
        and relations.relation_type = 'friend') as s,
     accounts a
where a.id = (select account_id from settings where relation_id = s.relation_id and (settings.account_id != ? or is_self = true))
order by s.pin_time
`

type GetFriendPinSettingsOrderByPinTimeParams struct {
	AccountID   int64
	AccountID_2 int64
}

type GetFriendPinSettingsOrderByPinTimeRow struct {
	RelationID    int64
	NickName      string
	PinTime       time.Time
	IsPin         bool
	IsShow        bool
	IsNotDisturb  bool
	AccountID     int64
	AccountName   string
	AccountAvatar string
}

func (q *Queries) GetFriendPinSettingsOrderByPinTime(ctx context.Context, arg *GetFriendPinSettingsOrderByPinTimeParams) ([]*GetFriendPinSettingsOrderByPinTimeRow, error) {
	rows, err := q.query(ctx, q.getFriendPinSettingsOrderByPinTimeStmt, getFriendPinSettingsOrderByPinTime, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendPinSettingsOrderByPinTimeRow{}
	for rows.Next() {
		var i GetFriendPinSettingsOrderByPinTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.PinTime,
			&i.IsPin,
			&i.IsShow,
			&i.IsNotDisturb,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendSettingsByName = `-- name: GetFriendSettingsByName :many
SELECT
    s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
    a.id AS account_id,
    a.name AS account_name,
    a.avatar AS account_avatar,
    COUNT(*) OVER () AS total
FROM (
         SELECT
             s.relation_id,
             s.nick_name,
             s.is_not_disturb,
             s.is_pin,
             s.pin_time,
             s.is_show,
             s.last_show,
             s.is_self
         FROM settings s
                  INNER JOIN relations r ON s.relation_id = r.id
         WHERE
             s.account_id = ?
           AND r.relation_type = 'friend'
     ) AS s
         CROSS JOIN accounts a
WHERE
    a.id = (
        SELECT account_id
        FROM settings
        WHERE
            relation_id = s.relation_id
          AND (settings.account_id != ? OR s.is_self = 1)
    )
  AND (
    a.name LIKE CONCAT('%', ?, '%')
        OR s.nick_name LIKE CONCAT('%', ?, '%')
    )
ORDER BY a.name
LIMIT ? OFFSET ?
`

type GetFriendSettingsByNameParams struct {
	AccountID   int64
	AccountID_2 int64
	CONCAT      interface{}
	CONCAT_2    interface{}
	Limit       int32
	Offset      int32
}

type GetFriendSettingsByNameRow struct {
	RelationID    int64
	NickName      string
	IsNotDisturb  bool
	IsPin         bool
	PinTime       time.Time
	IsShow        bool
	LastShow      time.Time
	IsSelf        bool
	AccountID     int64
	AccountName   string
	AccountAvatar string
	Total         interface{}
}

func (q *Queries) GetFriendSettingsByName(ctx context.Context, arg *GetFriendSettingsByNameParams) ([]*GetFriendSettingsByNameRow, error) {
	rows, err := q.query(ctx, q.getFriendSettingsByNameStmt, getFriendSettingsByName,
		arg.AccountID,
		arg.AccountID_2,
		arg.CONCAT,
		arg.CONCAT_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendSettingsByNameRow{}
	for rows.Next() {
		var i GetFriendSettingsByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendSettingsOrderByName = `-- name: GetFriendSettingsOrderByName :many









select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       a.id as account_id,
       a.name as account_name,
       a.avatar as account_avatar
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from settings,
           relations
      where settings.account_id = ?
        and settings.relation_id = relations.id
        and relations.relation_type = 'friend') as s,
     accounts a
where a.id = (select account_id from settings where relation_id = s.relation_id and (settings.account_id != ? or s.is_self = true))
order by a.name
`

type GetFriendSettingsOrderByNameParams struct {
	AccountID   int64
	AccountID_2 int64
}

type GetFriendSettingsOrderByNameRow struct {
	RelationID    int64
	NickName      string
	IsNotDisturb  bool
	IsPin         bool
	PinTime       time.Time
	IsShow        bool
	LastShow      time.Time
	IsSelf        bool
	AccountID     int64
	AccountName   string
	AccountAvatar string
}

// SELECT
//
//	s.relation_id,
//	s.nick_name,
//	s.is_not_disturb,
//	s.is_pin,
//	s.pin_time,
//	s.is_show,
//	s.last_show,
//	s.is_self,
//	a.id AS account_id,
//	a.name AS account_name,
//	a.avatar AS account_avatar
//
// FROM (
//
//	    SELECT
//	        st.relation_id,
//	        st.nick_name,
//	        st.is_not_disturb,
//	        st.is_pin,
//	        st.pin_time,
//	        st.is_show,
//	        st.last_show,
//	        st.is_self,
//	        CASE
//	            WHEN rt.relation_type = 'friend' THEN rt.account2_id
//	            ELSE NULL
//	            END AS friend_account_id
//	    FROM settings st
//	             INNER JOIN relations rt
//	                        ON st.relation_id = rt.id
//	                            AND rt.relation_type = 'friend'
//	    WHERE
//	        st.account_id = ?
//	      AND st.is_show = true
//	) s
//	    INNER JOIN accounts a
//	               ON a.id = s.friend_account_id
//
// ORDER BY
//
//	s.last_show DESC;
//
// -- name: GetFriendShowSettingsOrderByShowTime :many
// SELECT
//
//	s.relation_id,
//	s.nick_name,
//	s.is_not_disturb,
//	s.is_pin,
//	s.pin_time,
//	s.is_show,
//	s.last_show,
//	s.is_self,
//	a.id AS account_id,
//	a.name AS account_name,
//	a.avatar AS account_avatar
//
// FROM (
//
//	    SELECT
//	        settings.relation_id,
//	        settings.nick_name,
//	        settings.is_not_disturb,
//	        settings.is_pin,
//	        settings.pin_time,
//	        settings.is_show,
//	        settings.last_show,
//	        settings.is_self
//	    FROM
//	        settings
//	            JOIN
//	        relations ON settings.relation_id = relations.id
//	    WHERE
//	        settings.account_id =?  -- 这里的? 是占位符，实际使用时需要替换为具体的值
//	      AND settings.is_show = true
//	      AND relations.relation_type = 'friend'
//	) AS s
//	    JOIN
//	accounts a ON a.id = (
//	    SELECT
//	        sub_settings.account_id  -- 给子查询中的 settings 表取别名 sub_settings
//	    FROM
//	        settings AS sub_settings  -- 给子查询中的 settings 表取别名 sub_settings
//	    WHERE
//	        sub_settings.relation_id = s.relation_id
//	      AND (sub_settings.account_id !=? OR sub_settings.is_self = true)  -- 这里的? 是占位符，实际使用时需要替换为具体的值
//	)
//
// ORDER BY
//
//	s.last_show DESC;
//
// -- name: GetFriendShowSettingsOrderByShowTime :many
// select s.*,
//
//	r.id,r.group_avatar,r.group_name,r.group_description,r.created_at
//
// from (select relation_id,
//
//	        nick_name,
//	        is_not_disturb,
//	        is_pin,
//	        pin_time,
//	        is_show,
//	        last_show,
//	        is_self
//	 from settings,
//	      relations
//	 where settings.account_id = ?
//	   and settings.relation_id = relations.id
//	   and settings.is_show = true
//	   and relations.relation_type = 'friend') as s,
//	relations r
//
// where r.id = (select relation_id from settings where relation_id = s.relation_id and settings.account_id = ? limit 1)
// order by s.last_show desc;
func (q *Queries) GetFriendSettingsOrderByName(ctx context.Context, arg *GetFriendSettingsOrderByNameParams) ([]*GetFriendSettingsOrderByNameRow, error) {
	rows, err := q.query(ctx, q.getFriendSettingsOrderByNameStmt, getFriendSettingsOrderByName, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendSettingsOrderByNameRow{}
	for rows.Next() {
		var i GetFriendSettingsOrderByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.AccountID,
			&i.AccountName,
			&i.AccountAvatar,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendShowSettingsOrderByShowTime = `-- name: GetFriendShowSettingsOrderByShowTime :many
SELECT
    s.relation_id AS RelationID,
    s.nick_name AS NickName,
    s.is_not_disturb AS IsNotDisturb,
    s.is_pin AS IsPin,
    s.pin_time AS PinTime,
    s.is_show AS IsShow,
    s.last_show AS LastShow,
    s.is_self AS IsSelf,
    a.id AS AccountID,
    a.name AS AccountName,
    a.avatar AS AccountAvatar,
    a.create_at AS AccountCreateAt  -- 新增字段
FROM (
         SELECT
             st.relation_id,
             st.nick_name,
             st.is_not_disturb,
             st.is_pin,
             st.pin_time,
             st.is_show,
             st.last_show,
             st.is_self,
             r.relation_type
         FROM settings st
                  INNER JOIN relations r
                             ON st.relation_id = r.id
         WHERE
             st.account_id = ?
           AND st.is_show = TRUE
           AND r.relation_type = 'friend'
     ) AS s
         INNER JOIN accounts a
                    ON a.id = (
                        SELECT account_id
                        FROM settings
                        WHERE
                            relation_id = s.relation_id
                          AND (settings.account_id != ? OR is_self = TRUE)
                        LIMIT 1
                    )
ORDER BY s.last_show DESC
`

type GetFriendShowSettingsOrderByShowTimeParams struct {
	AccountID   int64
	AccountID_2 int64
}

type GetFriendShowSettingsOrderByShowTimeRow struct {
	Relationid      int64
	Nickname        string
	Isnotdisturb    bool
	Ispin           bool
	Pintime         time.Time
	Isshow          bool
	Lastshow        time.Time
	Isself          bool
	Accountid       int64
	Accountname     string
	Accountavatar   string
	Accountcreateat time.Time
}

func (q *Queries) GetFriendShowSettingsOrderByShowTime(ctx context.Context, arg *GetFriendShowSettingsOrderByShowTimeParams) ([]*GetFriendShowSettingsOrderByShowTimeRow, error) {
	rows, err := q.query(ctx, q.getFriendShowSettingsOrderByShowTimeStmt, getFriendShowSettingsOrderByShowTime, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFriendShowSettingsOrderByShowTimeRow{}
	for rows.Next() {
		var i GetFriendShowSettingsOrderByShowTimeRow
		if err := rows.Scan(
			&i.Relationid,
			&i.Nickname,
			&i.Isnotdisturb,
			&i.Ispin,
			&i.Pintime,
			&i.Isshow,
			&i.Lastshow,
			&i.Isself,
			&i.Accountid,
			&i.Accountname,
			&i.Accountavatar,
			&i.Accountcreateat,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupList = `-- name: GetGroupList :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       r.id as relation_id,
       r.group_name as group_name,
       r.group_description as group_discription,
       r.group_avatar as group_avatar,
       count(*) over () as total
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from settings,
           relations
      where settings.account_id = ?
        and settings.relation_id = relations.id
        and relations.relation_type = 'group') as s,
    relations r
where r.id = (select s.relation_id from settings where relation_id = s.relation_id and (settings.account_id = ?))
order by s.last_show
`

type GetGroupListParams struct {
	AccountID   int64
	AccountID_2 int64
}

type GetGroupListRow struct {
	RelationID       int64
	NickName         string
	IsNotDisturb     bool
	IsPin            bool
	PinTime          time.Time
	IsShow           bool
	LastShow         time.Time
	IsSelf           bool
	RelationID_2     int64
	GroupName        sql.NullString
	GroupDiscription sql.NullString
	GroupAvatar      sql.NullString
	Total            interface{}
}

func (q *Queries) GetGroupList(ctx context.Context, arg *GetGroupListParams) ([]*GetGroupListRow, error) {
	rows, err := q.query(ctx, q.getGroupListStmt, getGroupList, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupListRow{}
	for rows.Next() {
		var i GetGroupListRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.RelationID_2,
			&i.GroupName,
			&i.GroupDiscription,
			&i.GroupAvatar,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembers = `-- name: GetGroupMembers :many
SELECT account_id
FROM settings
WHERE relation_id = ?
`

func (q *Queries) GetGroupMembers(ctx context.Context, relationID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.getGroupMembersStmt, getGroupMembers, relationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var account_id int64
		if err := rows.Scan(&account_id); err != nil {
			return nil, err
		}
		items = append(items, account_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMembersByID = `-- name: GetGroupMembersByID :many
SELECT
    a.id,
    a.name,
    a.avatar,
    s.nick_name,
    s.is_leader
FROM accounts a
         LEFT JOIN settings s ON a.id = s.account_id
WHERE s.relation_id = ?
LIMIT ? OFFSET ?
`

type GetGroupMembersByIDParams struct {
	RelationID int64
	Limit      int32
	Offset     int32
}

type GetGroupMembersByIDRow struct {
	ID       int64
	Name     string
	Avatar   string
	NickName sql.NullString
	IsLeader sql.NullBool
}

func (q *Queries) GetGroupMembersByID(ctx context.Context, arg *GetGroupMembersByIDParams) ([]*GetGroupMembersByIDRow, error) {
	rows, err := q.query(ctx, q.getGroupMembersByIDStmt, getGroupMembersByID, arg.RelationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupMembersByIDRow{}
	for rows.Next() {
		var i GetGroupMembersByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.NickName,
			&i.IsLeader,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupPinSettingsOrderByPinTime = `-- name: GetGroupPinSettingsOrderByPinTime :many
select s.relation_id,
       s.nick_name,
       s.pin_time,
       s.is_show,
       s.is_not_disturb,
       s.is_pin,
        r.id,
        r.group_name,
        r.group_description,
        r.group_avatar,
        r.group_name,
        r.group_description,
        r.group_avatar
from (select settings.relation_id,settings.nick_name,settings.pin_time,settings.is_pin,settings.is_show,settings.is_not_disturb
      from settings,
           relations
      where settings.account_id = ?
      and settings.relation_id=relations.id
      and settings.is_pin=true
      and relation_type='group') as s,
    relations r
where r.id=(select relation_id
            from settings
            where relation_id = s.relation_id
            and settings.account_id = ?)
order by s.pin_time
`

type GetGroupPinSettingsOrderByPinTimeParams struct {
	AccountID   int64
	AccountID_2 int64
}

type GetGroupPinSettingsOrderByPinTimeRow struct {
	RelationID         int64
	NickName           string
	PinTime            time.Time
	IsShow             bool
	IsNotDisturb       bool
	IsPin              bool
	ID                 int64
	GroupName          sql.NullString
	GroupDescription   sql.NullString
	GroupAvatar        sql.NullString
	GroupName_2        sql.NullString
	GroupDescription_2 sql.NullString
	GroupAvatar_2      sql.NullString
}

func (q *Queries) GetGroupPinSettingsOrderByPinTime(ctx context.Context, arg *GetGroupPinSettingsOrderByPinTimeParams) ([]*GetGroupPinSettingsOrderByPinTimeRow, error) {
	rows, err := q.query(ctx, q.getGroupPinSettingsOrderByPinTimeStmt, getGroupPinSettingsOrderByPinTime, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupPinSettingsOrderByPinTimeRow{}
	for rows.Next() {
		var i GetGroupPinSettingsOrderByPinTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.PinTime,
			&i.IsShow,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.ID,
			&i.GroupName,
			&i.GroupDescription,
			&i.GroupAvatar,
			&i.GroupName_2,
			&i.GroupDescription_2,
			&i.GroupAvatar_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupSettingsByName = `-- name: GetGroupSettingsByName :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       r.id as realtion_id,
       r.group_name AS group_name,
       r.group_avatar AS group_avatar,
       r.group_description AS description,
       count(*) over () as total
from (select relation_id,
    nick_name,
    is_not_disturb,
    is_pin,
    pin_time,
    is_show,
    last_show,
    is_self
    from settings,
    relations
    where settings.account_id = ?
    and settings.relation_id = relations.id
    and relations.relation_type = 'group') as s,
    relations r
where r.id = (select s.relation_id from settings where s.relation_id=s.relation_id and (settings.account_id=?))
    and ((r.group_name like ('%' || ? || '%')))
order by (r.group_name)
limit ? offset ?
`

type GetGroupSettingsByNameParams struct {
	AccountID   int64
	AccountID_2 int64
	GroupName   sql.NullString
	Limit       int32
	Offset      int32
}

type GetGroupSettingsByNameRow struct {
	RelationID   int64
	NickName     string
	IsNotDisturb bool
	IsPin        bool
	PinTime      time.Time
	IsShow       bool
	LastShow     time.Time
	IsSelf       bool
	RealtionID   int64
	GroupName    sql.NullString
	GroupAvatar  sql.NullString
	Description  sql.NullString
	Total        interface{}
}

func (q *Queries) GetGroupSettingsByName(ctx context.Context, arg *GetGroupSettingsByNameParams) ([]*GetGroupSettingsByNameRow, error) {
	rows, err := q.query(ctx, q.getGroupSettingsByNameStmt, getGroupSettingsByName,
		arg.AccountID,
		arg.AccountID_2,
		arg.GroupName,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupSettingsByNameRow{}
	for rows.Next() {
		var i GetGroupSettingsByNameRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.RealtionID,
			&i.GroupName,
			&i.GroupAvatar,
			&i.Description,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupShowSettingsOrderByShowTime = `-- name: GetGroupShowSettingsOrderByShowTime :many
select s.relation_id, s.nick_name, s.is_not_disturb, s.is_pin, s.pin_time, s.is_show, s.last_show, s.is_self,
       r.id,r.group_avatar,r.group_name,r.group_description,r.created_at
from (select relation_id,
             nick_name,
             is_not_disturb,
             is_pin,
             pin_time,
             is_show,
             last_show,
             is_self
      from settings,
           relations
      where settings.account_id = ?
        and settings.relation_id = relations.id
        and settings.is_show = true
        and relations.relation_type = 'group') as s,
     relations r
where r.id = (select relation_id from settings where relation_id = s.relation_id and settings.account_id = ? limit 1)
order by s.last_show desc
`

type GetGroupShowSettingsOrderByShowTimeParams struct {
	AccountID   int64
	AccountID_2 int64
}

type GetGroupShowSettingsOrderByShowTimeRow struct {
	RelationID       int64
	NickName         string
	IsNotDisturb     bool
	IsPin            bool
	PinTime          time.Time
	IsShow           bool
	LastShow         time.Time
	IsSelf           bool
	ID               int64
	GroupAvatar      sql.NullString
	GroupName        sql.NullString
	GroupDescription sql.NullString
	CreatedAt        sql.NullTime
}

func (q *Queries) GetGroupShowSettingsOrderByShowTime(ctx context.Context, arg *GetGroupShowSettingsOrderByShowTimeParams) ([]*GetGroupShowSettingsOrderByShowTimeRow, error) {
	rows, err := q.query(ctx, q.getGroupShowSettingsOrderByShowTimeStmt, getGroupShowSettingsOrderByShowTime, arg.AccountID, arg.AccountID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetGroupShowSettingsOrderByShowTimeRow{}
	for rows.Next() {
		var i GetGroupShowSettingsOrderByShowTimeRow
		if err := rows.Scan(
			&i.RelationID,
			&i.NickName,
			&i.IsNotDisturb,
			&i.IsPin,
			&i.PinTime,
			&i.IsShow,
			&i.LastShow,
			&i.IsSelf,
			&i.ID,
			&i.GroupAvatar,
			&i.GroupName,
			&i.GroupDescription,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRelationIDByAccountIDFromSettings = `-- name: GetRelationIDByAccountIDFromSettings :many
select relation_id
FROM settings
where account_id = ?
`

func (q *Queries) GetRelationIDByAccountIDFromSettings(ctx context.Context, accountID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.getRelationIDByAccountIDFromSettingsStmt, getRelationIDByAccountIDFromSettings, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var relation_id int64
		if err := rows.Scan(&relation_id); err != nil {
			return nil, err
		}
		items = append(items, relation_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSettingByID = `-- name: GetSettingByID :one
select account_id, relation_id, nick_name, is_not_disturb, is_pin, pin_time, is_show, last_show, is_leader, is_self
from settings
where account_id = ?
and relation_id =?
`

type GetSettingByIDParams struct {
	AccountID  int64
	RelationID int64
}

func (q *Queries) GetSettingByID(ctx context.Context, arg *GetSettingByIDParams) (*Setting, error) {
	row := q.queryRow(ctx, q.getSettingByIDStmt, getSettingByID, arg.AccountID, arg.RelationID)
	var i Setting
	err := row.Scan(
		&i.AccountID,
		&i.RelationID,
		&i.NickName,
		&i.IsNotDisturb,
		&i.IsPin,
		&i.PinTime,
		&i.IsShow,
		&i.LastShow,
		&i.IsLeader,
		&i.IsSelf,
	)
	return &i, err
}

const transferIsLeaderFalse = `-- name: TransferIsLeaderFalse :exec
UPDATE settings
SET is_leader = 0
WHERE relation_id = ? AND account_id = ?
`

type TransferIsLeaderFalseParams struct {
	RelationID int64
	AccountID  int64
}

func (q *Queries) TransferIsLeaderFalse(ctx context.Context, arg *TransferIsLeaderFalseParams) error {
	_, err := q.exec(ctx, q.transferIsLeaderFalseStmt, transferIsLeaderFalse, arg.RelationID, arg.AccountID)
	return err
}

const transferIsLeaderTrue = `-- name: TransferIsLeaderTrue :exec
UPDATE settings
SET is_leader = 1
WHERE relation_id = ? AND account_id = ?
`

type TransferIsLeaderTrueParams struct {
	RelationID int64
	AccountID  int64
}

func (q *Queries) TransferIsLeaderTrue(ctx context.Context, arg *TransferIsLeaderTrueParams) error {
	_, err := q.exec(ctx, q.transferIsLeaderTrueStmt, transferIsLeaderTrue, arg.RelationID, arg.AccountID)
	return err
}

const updateSettingDisturb = `-- name: UpdateSettingDisturb :exec
update settings
set is_not_disturb = ?
where account_id = ?
and relation_id =?
`

type UpdateSettingDisturbParams struct {
	IsNotDisturb bool
	AccountID    int64
	RelationID   int64
}

func (q *Queries) UpdateSettingDisturb(ctx context.Context, arg *UpdateSettingDisturbParams) error {
	_, err := q.exec(ctx, q.updateSettingDisturbStmt, updateSettingDisturb, arg.IsNotDisturb, arg.AccountID, arg.RelationID)
	return err
}

const updateSettingNickName = `-- name: UpdateSettingNickName :exec
update settings
set nick_name = ?
where account_id =?
and relation_id =?
`

type UpdateSettingNickNameParams struct {
	NickName   string
	AccountID  int64
	RelationID int64
}

func (q *Queries) UpdateSettingNickName(ctx context.Context, arg *UpdateSettingNickNameParams) error {
	_, err := q.exec(ctx, q.updateSettingNickNameStmt, updateSettingNickName, arg.NickName, arg.AccountID, arg.RelationID)
	return err
}

const updateSettingPin = `-- name: UpdateSettingPin :exec
update settings
set is_pin = ?
where account_id=?
and  relation_id= ?
`

type UpdateSettingPinParams struct {
	IsPin      bool
	AccountID  int64
	RelationID int64
}

func (q *Queries) UpdateSettingPin(ctx context.Context, arg *UpdateSettingPinParams) error {
	_, err := q.exec(ctx, q.updateSettingPinStmt, updateSettingPin, arg.IsPin, arg.AccountID, arg.RelationID)
	return err
}

const updateSettingShow = `-- name: UpdateSettingShow :exec
update settings
set  is_show = ?
where account_id =?
and relation_id =?
`

type UpdateSettingShowParams struct {
	IsShow     bool
	AccountID  int64
	RelationID int64
}

func (q *Queries) UpdateSettingShow(ctx context.Context, arg *UpdateSettingShowParams) error {
	_, err := q.exec(ctx, q.updateSettingShowStmt, updateSettingShow, arg.IsShow, arg.AccountID, arg.RelationID)
	return err
}
